## MySQL

### 1、MySQL架构

#### 1.1、MySQL 结构

**问：MySQL内部结构是什么样的？分几层？各自有什么作用？** 大概率不会考，不实用，但是考了把层答上就行

1. 连接层：（==建立连接，鉴权，SSL安全，为连接提供权限==）
   1. 主要完成类似于连接处理、授权认证、及相关的安全方案
   2. 在该层上引入线程池的概念，为通过认证安全接入的客户端提供线程
   3. 同样在该层上实现基于SSL的安全链接。
   4. 服务器也会为安全接入的每个客户端验证它所具有的操作权限
2. 服务层：（==大部分的核心服务功能，查询解析、分析、优化、缓存、以及所有的内置函数==）
   1. 主要完成大部分的核心服务功能，包括查询解析、分析、优化、缓存、以及所有的内置函数
   2. 所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等
3. 引擎层：（==MySQL中数据的存储和提取==）
   - 真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信
4. 存储层：（==存储数据的地方==）
   - 主要是将数据存储在文件系统上，并完成与存储引擎的交互



#### 1.2、sql执行过程

**问：一条sql在MySQL中是如何执行的？**



![image-20210910145217815](D:\Users\chongfeng\Desktop\知识体系\src\MySQL\sql执行流程.png)



#### 1.3、InnoDB 和 MyISAM

**问：MySQL有哪些存储引擎？为什么要用InnoDB？**表里得记住

MyISAM，InnoDB

MyISAM：节约空间，速度较快

InnoDB：安全性高，支持外键，事务，行锁

|                  | MyISAM                                                       | InnoDB                                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事务支持         | 不支持                                                       | 支持                                                         |
| 外键支持         | 不支持                                                       | 支持                                                         |
| 聚簇索引         | 非聚簇索引（文件和索引分离的且独立的，索引保存的是数据文件的指针） | 聚簇索引（聚簇索引的文件放在主键索引的叶子上，先查主键索引再查辅助索引） |
| 保存表的具体行数 | 保存（count（*）时直接获取到）                               | 不保存（count（*）时扫全表）                                 |
| 行锁支持         | 表锁                                                         | 行锁                                                         |



### 2、MySQL索引

#### 2.1、MySQL索引

==索引：高效获取数据的数据结构，本质：数据结构，目的：提高查询效率==

存储：一般以索引文件的形式存储在磁盘上



#### 2.2、MySQL索引的优缺点

**问：MySQL的优势和劣势是什么？**

优势：

1. ==提高数据检索效率，降低数据库IO成本==
2. ==降低数据排序的成本，降低CPU的消耗==

劣势

1. 索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以==也需要占用内存==
2. 虽然索引大大==提高了查询速度，同时却会降低更新表的速度==。（如对表进行insert、update和delete。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的的键值变化后的索引信息）



**2.3、数据库索引的原理，为什么要用B+树，为什么不用二叉树？为什么不用B树？**

**问：介绍下BTree 和 B+Tree**

![image-20210910152848141](D:\Users\chongfeng\Desktop\知识体系\src\MySQL\BTree.png)

![image-20210910152954505](D:\Users\chongfeng\Desktop\知识体系\src\MySQL\B+Tree.png)

**问：MySQL为什么选择B+Tree？** 必须说清

1. B+Tree是B TREE的变种，B TREE能解决的问题，B+TREE也能够解决（降低树的⾼度，增⼤节点存储数据量）==都能解决问题== 

2. B+Tree扫库和扫表能⼒更强。如果我们要根据索引去进⾏数据表的扫描，对B TREE进⾏扫描，需要把整棵树遍历⼀遍，⽽B+TREE只需要遍历他的所有叶⼦节点即可（叶⼦节点之间有引⽤）。 ==扫库扫表能力==

3. B+TREE磁盘读写能⼒更强。他的根节点和⽀节点不保存数据区，所以根节点和⽀节点同样⼤⼩的情况下，保存的关键字要⽐B TREE要多。⽽叶⼦节点不保存⼦节点引⽤，能⽤于保存更多的关键字和数据。所以，B+TREE读写⼀次磁盘加载的关键字⽐B TREE更多。 ==读写一次加载的关键字更多==

4. B+Tree排序能⼒更强。上⾯的图中可以看出，B+Tree天然具有排序功能。==天然具有排序功能== 

5. B+Tree查询性能稳定。B+Tree数据只保存在叶⼦节点，每次查询数据，查询IO次数⼀定是稳定的。当然这个每个⼈的理解都不同，因为在B TREE如果根节点命中直接返回，确实效率更⾼。 ==性能稳定==



#### 2.4、聚簇索引和非聚簇索引

**问：聚簇索引与非聚簇索引的区别？什么是回表查询？介绍下覆盖索引？** 了解

聚簇索引：InnoDB引擎索引结构的叶⼦节点的数据域，存放的就是实际的数据记录。==数据⽂件本身就是主键索引⽂件，辅助索引存的主键，从辅助索引找出主键，再在数据文件通过主键找到数据，这个叫回表查询==

非聚簇索引：==主键索引和辅助索引分开存放==

InnoDB是聚簇索引，MyISAM是非聚簇索引

聚簇索引，非聚簇索引，如果数据迁移，聚簇索引更容易完成    ==数据迁移==

覆盖索引：就是select的数据列只⽤从索引中就能够取得，不必读取数据⾏，MySQL可以利⽤索引返回select列表中的字段，⽽不必根据索引再次读取数据⽂件，换句话说查询列要被所建的索引覆盖（所以少用select * 就是为了走覆盖索引）



### 3、MySQL事务

#### 3.1、MySQL事务的四大特性ACID

**问：MySQL事务的四大特性ACID是什么？  必须掌握**

- A 原子性：要么都成功，要么都失败
- C 一致性：事务前后的数据完整性要保证一致
- I 隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
- D 持久性：事务一旦提交则不可逆，被持久化到数据库中

**问：并发事务处理带来的问题？**  掌握

1. 更新丢失：AB同时更新，有一方的更新丢失
   1. 第一类更新丢失：A事务开始和结束期间，B开启事务并提交，A回滚导致B的提交失效
   2. 第二类更新丢失：A事务修改，B事务修改，B提交，A提交，B更新的记录丢失
2. 脏读：A读B更新的数据（未提交事务），B回滚，A读的是脏数据
3. 不可重复读：A在事务中多次读取同一行数据，B做了更新并提交，A再读，结果不一致
4. 幻读：A在事务中读取多行，B做了插入或删除数据，A再次读取的时候发现多了一些原本不存在的记录



#### 3.2、事务隔离级别

**问：MySQL事务隔离级别有哪些？**

1. read-uncommitted（读未提交）：可能发生脏读、幻读、不可重复读
2. read-committed（读已提交）：解决了脏读
3. repeatable-read（可重复读）：解决了脏读和不可重复读（MySQL默认隔离级别）
4. serializable（串行化）：全解决了



#### 3.3、MVCC

**问：MVCC了解吗？作用在哪个隔离级别？怎么实现的？**

MVCC：多版本并发控制，其实指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本，多版本之间串联起来就形成了一条版本链。

作用在实现读已提交和可重复读

实现原理：每个版本以链表形式记录在undolog日志上

数据库并发场景有三种，分别为：

- 读-读：不存在任何问题，也不需要并发控制
- 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

MVCC好处：

- 并发读写数据库，不相互阻塞
- 解决了脏读、幻读、不可重复读的问题，但是没解决更新丢失的问题

所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：

- MVCC + 悲观锁
  MVCC解决读写冲突，悲观锁解决写写冲突
- MVCC + 乐观锁
  MVCC解决读写冲突，乐观锁解决写写冲突
  这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题



#### 3.4、MySQL锁机制

- 悲观锁：select 语句后边加了for update相当于加了排它锁(写锁)
- 乐观锁：⼀般我们在数据库表中添加⼀个版本字段version来实现

InnoDB的行锁

- 明确指定主键，并且有此值，row lock

~~~sql
select * from products where id='3' for update;
select * from products where id='3' and type=1 for update;
~~~

- 明确指定主键，若查无值，无lock

~~~sql
select * from products where id='-1' for update;
~~~

- 无主键，table lock

~~~sql
select * from products where name='Mouse' for update;
~~~

- 主键不明确，table lock

~~~sql
select * from products where id<>'3' for update;
~~~



### 4、MySQL性能优化

#### 4.1、慢查询日志

