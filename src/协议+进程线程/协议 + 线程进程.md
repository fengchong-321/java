## 协议 + 线程/进程

[TOC]

### 1、http 和 https 

基本概念：

1. HTTP：是互联⽹上应⽤最为⼴泛的⼀种⽹络协议，是⼀个==**客户端和服务器端请求和应答的标准(TCP)**==，⽤于从 WWW服务器传输超⽂本到本地浏览器的传输协议，它可以使浏览器更加⾼效，使⽹络传输减少。
2. HTTPS：是以安全为⽬标的HTTP通道，简单讲是HTTP的安全版，即==**HTTP下加⼊SSL层，HTTPS的安全基础是 SSL，因此加密的详细内容就需要SSL。**== 
3. ==**HTTPS**==协议的主要有以下==**作⽤**==：==**⼀是建⽴⼀个信息安全通道，来保证数据传输的安全；另外就是确认⽹站的真实性。**==

> 考察点

#### 1.1、http常见状态码

**问：http状态码2开头，3开头，4开头，5开头，都代表什么？ ==必掌握==**

| 分类 | 分类描述                                       |
| ---- | ---------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执⾏操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进⼀步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或⽆法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发⽣了错误 |

**问：常见的http的状态码有哪些？答上60%即可**

| 状态码                        | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| ==200 OK==                    | 请求成功。一般用于GET与POST请求                              |
| ==204 No Content==            | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档<br />一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。 |
| 206 Partial Content           | 部分内容。服务器成功处理了部分GET请求<br />该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 |
| ==301 Moved Permanently==     | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<br />若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。 同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。 |
| 302 Found                     | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI<br />若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。<br />同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。<br />当我们在做活动时，登录到首页自动重定向，进入活动页面。<br />未登陆的用户访问用户中心重定向到登录页面。<br />访问404页面重新定向到首页。 |
| 303 See Other                 | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304 Not Modified              | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<br />提高性能，使用浏览器缓存 |
| 307 Temporary Redirect        | 临时重定向，与302相似                                        |
| ==400  Bad Request==          | 客户端请求的语法错误，服务器无法理解                         |
| 401 Unauthorized              | 请求要求用户的身份认证                                       |
| ==403 Forbidden==             | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| ==404 Not Found==             | 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 |
| 405 Method Not Allowed        | 该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。<br />客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下<br />Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE |
| ==500 Internal Server Error== | 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。 |
| ==502 Bad Gateway==           | 该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的<br />注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复 |
| 503 Service Unavailable       | 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。<br />服务器停机维护时，主动用503响应请求；<br />nginx 设置限速，超过限速，会返回503。 |
| ==504 Gateway Timeout==       | 该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。<br />代码执行时间超时，或者发生了死循环。 |



#### 1.2、http 请求 Post 和 Get 的区别

**问：http的post请求和get请求有什么区别？ 60%即可，最后一条必答**

- GET参数通过URL传递，POST放在Request body中。==参数传递方式不一致==
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。==POST稍微安全一些==
- GET请求在URL中传送的参数是有长度限制的，而POST么有。==GET有长度限制==
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。==GET会被浏览器主动cache==
- 对于GET方式的请求，浏览器会把http header和data一并发送出去，而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data。==GET一次发送，POST两次发送，多个一次header发送==



#### 1.3、http和https的区别

**问：http和https有什么区别？ 60%即可，134比较重要**

1. ==HTTP 是明⽂传输协议，HTTPS 协议是由 SSL+HTTP 协议==构建的可进⾏加密传输、身份认证的⽹络协议，⽐ HTTP 协议安全。
2. HTTPS⽐HTTP更加安全，==对搜索引擎更友好，利于SEO,⾕歌、百度优先索引HTTPS⽹⻚==; 
3. ==HTTPS需要⽤到SSL证书==，⽽HTTP不⽤【（==HTTPS是安装SSL的服务器，HTTP是未安装SSL的服务器==）】; 
4. HTTPS标准端⼝==443==，HTTP标准端⼝==80==; 
5. ==HTTPS基于传输层，HTTP基于应⽤层==; 
6. ==HTTPS在浏览器显示绿⾊安全锁，HTTP没有显示==; 



#### 1.4、https的加密过程

**问：说说https的加密过程 ？把上面3行答上就行**

答：简单的说，共享密钥加密报文 + 公开密钥加密共享密钥 + ssl证书  保证安全

通俗的讲：A 要请求 B的 内容， A 通知B，我要请求了，B给了A一把锁头x，钥匙x在B那里，A把报文用锁y把报文加密了，并把锁头y的钥匙y用 锁头x 锁住，并返给 B，然后进行 http 的完整请求

https://www.jianshu.com/p/e30a8c4fa329



### 2、TCP 和 UDP

基本概念：

TCP/IP网络模型：网络接口层，网络层IP，运输层，应用层

网络接口层：物理层级，如果wifi。  网络层IP：IP地址。  运输层：规定计算机间怎么传输。应用层：传输什么怎么处理

UDP：UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。

TCP：TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议



#### 2.1、TCP 和 Http的区别和关联

**问：TCP和http有关系吗？  了解**

HTTP的责任是去定义数据，在两台计算机相互传递信息时，HTTP规定了每段数据以什么形式表达才是能够被另外一台计算机理解。

而TCP所要规定的是数据应该怎么传输才能稳定且高效的传递与计算机之间。



#### 2.2、TCP和UDP的区别

**问：TCP和UDP有什么区别？  60%**

| UDP                                        | TCP                                |
| ------------------------------------------ | ---------------------------------- |
| 无连接                                     | 面向连接                           |
| 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一                       |
| 对应用层交付的报文直接打包                 | 面向字节流，对字节流的解释在应⽤层 |
| 不可靠                                     | 可靠传输                           |
| 首部开销小，仅8字节                        | 首部最小20字节，最大60字节         |



#### 2.3、TCP的三次握手和四次挥手

**问：讲讲TCP建立连接和断开连接的过程？  必须说清楚**

建立连接（三次握手）：A 通知 B 要建立连接， B 通知 A 可以建立连接， A 通知 B 收到了可以建立的通知 ，建立连接 

断开连接（四次挥手）：A 通知 B 要释放连接， B 通知 A 准备释放连接但是我需要整理， B 通知 A 我整理好了你可以释放了， A  通知 B 我已经释放了，四次挥手结束，但是 A还会等待 2MSL在关闭

**问：为什么握手需要3次，挥手却需要4次？ 了解**

建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。

释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

**问：等待2MSL（最大报文段生存时间）的意义？ 了解**

1. 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失
2. 这样可以保证本次连接的所有数据都从网络中消失，为了区分新连接和老连接的数据

![image-20210810165721398](D:\Users\chongfeng\Desktop\学习笔记\学习\三次握手.png)

![image-20210810173305471](D:\Users\chongfeng\Desktop\学习笔记\学习\四次挥手.png)



#### 2.4、TCP流量控制和拥塞控制

问：TCP怎么实现的可靠传输？ 流量控制和拥塞控制了解吗？ 了解，能说清楚

流量控制：防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理

措施：通过滑动窗口实现，即接收方有个接收窗口，接收方会根据自己的处理调节接收窗口大小，发送方把整个报文分段发给接收方，发送方发送的分段数据不允许超过窗口大小（单位字节），接收方通知窗口为0后（通知还包含下次接收报文的起始位置），就不允许发送方再发送了，发送方启动计时器，

拥塞控制：防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞

措施：四种算法，慢开始，拥塞避免，快重传，快恢复，过程是，先从慢开始开始，发送窗口以指数增大，增大到门限值，开启拥塞避免算法，发送窗口以线性增大，直到触发数据丢失，如果判断为网络拥塞（没有收到ACK），则门限根据当前最大发送窗口减半，重新开启慢开始和拥塞避免，如果判断是丢包非网络拥塞（连续收到3个接收方发的重复确认）则进入快重传算法，快重传算法不用等待重传计时器，而立即重传，进入快恢复算法，这时发送方窗口大小变为门限值，继续开始拥塞避免算法

https://www.cnblogs.com/mseddl/p/11525411.html

![image-20210810221907602](D:\Users\chongfeng\Desktop\学习笔记\学习\流量控制.png)

![image-20210810222613380](D:\Users\chongfeng\AppData\Roaming\Typora\typora-user-images\image-20210810222613380.png)

![image-20210810223830498](D:\Users\chongfeng\Desktop\学习笔记\学习\TCP拥塞控制2.png)

![image-20210810224611215](D:\Users\chongfeng\Desktop\学习笔记\学习\TCP快重传.png)

![image-20210810224644843](D:\Users\chongfeng\Desktop\学习笔记\学习\TCP快恢复.png)

![image-20210908174217701](D:\Users\chongfeng\Desktop\知识体系\src\快恢复算法.png)

### 3、进程和线程

进程

- 狭义的定义：进程就是==⼀段程序的执⾏过程==。

- ⼴义定义：==进程是⼀个具有⼀定独⽴功能的程序关于某次数据集合的⼀次运⾏活动，它是操作系统分配资源的基本单元。==

  简单来讲进程的概念主要有两点：第⼀，进程是⼀个实体。每⼀个进程都有它⾃⼰的地址空间，⼀般情况下，包括⽂本区域（text region）、数据区域（data region）和堆栈（stack region）。⽂本区域存储处理器执⾏的代码；数据区域存储变量和进程执⾏期间使⽤的动态分配的内存；堆栈区域存储着活动过程中调⽤的指令和本地变量。第⼆，进程是⼀个“执⾏中的程序”。程序是⼀个没有⽣命的实体，只有处理器赋予程序⽣命时，它才能成为⼀个活动的实体，我们称其为进程。

- 进程组成：==程序段，数据段 和 程序控制块PCB（四个部分组成：描述信息，控制和管理信息，资源分配清单，处理相关信息）==

线程

- 一个程序中，这些独立运行的程序片段叫做线程
- 线程的组成：==线程描述信息（包含线程id，线程名称，线程优先级，线程状态，其他线程信息），程序计数器和栈内存组成==



#### 3.1、进程状态

问：讲讲进程的状态有哪些？ 标注必须掌握，具体细节不需要掌握

- ==**可运行状态（task_running）**==：进程要么在CPU上执⾏，要么准备执⾏
- ==**可中断的等待状态（task_interruptible）**==：进程被挂起（睡眠），直到某个条件变为真。产⽣⼀个硬件中断、释放进程正在等待的系统资源、或传递⼀个信号都是可以唤醒进程的条件（把进程状态放回到task_running）。 
- ==**不可中断的等待状态（task_uninterruptible）**==：与可中断的等待状态类似，但有⼀个例外，把信号传递到该睡眠进程时，不能改变它的状态。这种状态很少⽤到，但在⼀些特定条件下（进程必须等待，直到⼀个不能被中断的时事件发⽣），这种状态是很有⽤的。例如，当进程打开⼀个设备⽂件，其相应的设备驱动程序开始探测相应的硬件设备时会⽤到这种状态。探测完成以前，设备驱动程序不能被中断，否则，硬件设备会处于不可预知的状态。
- ==**暂停状态（task_stoped）**==：进程的执⾏被暂停。当进程接收到sigstop、sigstp、sigttin或sigttou信号后，进⼈暂停状态。
- ==**跟踪状态（task_traced）**==：进程的执⾏已由debugger程序暂停。当⼀个进程被另⼀个进程监控时（例如 debugger执⾏ptrace()系统调⽤监控⼀个测试程序）任何信号都可以把这个进程置于task_traced状态
- ==**僵死状态（exit_zombie）**==：进程的执⾏被终⽌，但是⽗进程还没发布wait4()或waitpid()系统调⽤来返回有关死亡进程的信息。发布wait()类系统调⽤前，内核不能丢弃包含在死进程描述符中的数据，因为⽗进程可能还需要它。
- ==**僵死撤销状态（exit_dead）**==：终状态：由于⽗进程刚发出wait4()或waitpid()系统调⽤，因⽽进程由系统删 除。为了防⽌其他执⾏线程在同⼀个进程上也执⾏wait()类系统调⽤（这也是⼀种竞争条件），⽽把进程的状 态由僵死（EXIT_ZOMBIE）状态改为僵死撤销状态（EXIT_DEAD



#### 3.2、线程状态

问：讲讲java线程状态有哪些？ 必须掌握，说清楚，图内容需要说清楚，LockSupport类的不用管，系统调度不用管

1. ==**初始(NEW)**==：新创建了一个线程对象，但还没有调用start()方法。
2. ==**运行(RUNNABLE)**==：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. ==**阻塞(BLOCKED)**==：表示线程阻塞于锁。
4. ==**等待(WAITING)**==：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. ==**超时等待(TIMED_WAITING)**==：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. ==**终止(TERMINATED)**==：表示该线程已经执行完毕。

![image-20210909143038800](D:\Users\chongfeng\Desktop\知识体系\src\线程状态.png)



#### 3.3、进程和线程的区别

问：进程和线程有哪些区别？ 30%，10条大多说的一个意思，答上资源分配以及单独空间和共享内存

进程和线程的主要差别在于它们是不同的操作系统资源管理⽅式。进程有独⽴的地址空间，⼀个进程崩溃后，在保护模式下不会对其它进程产⽣影响，⽽线程只是⼀个进程中的不同执⾏路径。==不同的操作系统资源管理⽅式==

线程有⾃⼰的堆栈和局部变量，但线程之间没有单独的地址空间，⼀个线程死掉就等于整个进程死掉，所以多进程的程序要⽐多线程的程序健壮，但在进程切换时，耗费资源较⼤，效率要差⼀些。但对于⼀些要求同时进⾏并且⼜要共享某些变量的并发操作，只能⽤线程，不能⽤进程。==进程单独地址空间，线程共享内存==

答：

1. ⼀个程序⾄少有⼀个进程,==⼀个进程⾄少有⼀个线程==
2. ==线程的划分尺度⼩于进程==，使得多线程程序的==并发性高==
3. 进程在执⾏过程中拥有==独⽴的内存单元==，⽽多个线程==共享内存==，从⽽极⼤地提⾼了程序的运⾏效率
4. 线程在执⾏过程中与进程还是有区别的。每个独⽴的线程有⼀个程序运⾏的⼊⼝、顺序执⾏序列和程序的出⼝。但是线程不能够独⽴执⾏，必须依存在应⽤程序中，由应⽤程序提供多个线程执⾏控制。
5. ==从逻辑⻆度来看，多线程的意义在于⼀个应⽤程序中，有多个执⾏部分可以同时执⾏。但操作系统并没有将多个线程看做多个独⽴的应⽤，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。==
6. 进程的执⾏过程是线状的，尽管中间会发⽣中断或暂停，但该进程所拥有的资源只为该线状执⾏过程服务。⼀旦发⽣进程上下⽂切换，这些资源都是要被保护起来的。
7. ==线程的改变只代表了 CPU 执⾏过程的改变，⽽没有发⽣进程所拥有的资源变化==。
8. ==计算机内的软硬件资源的分配与线程⽆关，线程只能共享它所属进程的资源==。
9. 进程拥有⼀个完整的虚拟地址空间，不依赖于线程⽽独⽴存在；反之，线程是进程的⼀部分，没有⾃⼰的地址空间，与进程内的其他线程⼀起共享分配给该进程的所有资源。
10. 线程中执⾏时⼀般都要进⾏同步和互斥，因为他们共享同⼀进程的所有资源。